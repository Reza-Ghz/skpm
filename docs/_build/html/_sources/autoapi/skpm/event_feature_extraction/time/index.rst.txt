:py:mod:`skpm.event_feature_extraction.time`
============================================

.. py:module:: skpm.event_feature_extraction.time


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   skpm.event_feature_extraction.time.TimestampExtractor
   skpm.event_feature_extraction.time.Timestamp




.. py:class:: TimestampExtractor(features: Union[list, str] = 'all')


   Bases: :py:obj:`sklearn.base.ClassNamePrefixFeaturesOutMixin`, :py:obj:`sklearn.base.TransformerMixin`, :py:obj:`sklearn.base.BaseEstimator`

   Extract features from a timestamp column.

   The class needs a column with case ids and a column with timestamps. The validation of the columns is done in the fit method.

   :param case_col: {str}, default='case_id'
                    Name of the column containing the case ids.
   :param elc.timestamp: {str}, default='timestamp'
                         Name of the column containing the timestamps.
   :param features: list of features. Defaults to "all".
   :type features: Union[list, str], optional

   .. py:method:: fit(X: pandas.DataFrame, y=None)

      Fit transformer.
      Checks if the input is a dataframe, if it
      contains the required columns, validates
      the timestamp column, and the desired features.

      :param X: The data must contain a column with case ids and
                a column with timestamps.
      :type X: {DataFrame} of shape (n_samples, 2)
      :param y: Ignored.
      :type y: None.

      :returns: **self** -- Fitted transformer.
      :rtype: object


   .. py:method:: get_feature_names_out()

      Get output feature names for transformation.

      The feature names out will prefixed by the lowercased class name. For
      example, if the transformer outputs 3 features, then the feature names
      out are: `["class_name0", "class_name1", "class_name2"]`.

      :param input_features: Only used to validate feature names with the names seen in `fit`.
      :type input_features: array-like of str or None, default=None

      :returns: **feature_names_out** -- Transformed feature names.
      :rtype: ndarray of str objects


   .. py:method:: transform(X: pandas.DataFrame, y=None)

      Extract features from timestamp column.

      :param X: The data must contain a column with case ids and a column with timestamps.
      :type X: {dataframe} of shape (n_samples, 2)

      :returns: **X_tr** -- Transformed array.
      :rtype: {dataframe} of shape (n_samples, n_features)


   .. py:method:: _validate_data(X: pandas.DataFrame)

      Validate input data and set or check the `n_features_in_` attribute.

      :param X: The input samples.
                If `'no_validation'`, no validation is performed on `X`. This is
                useful for meta-estimator which can delegate input validation to
                their underlying estimator(s). In that case `y` must be passed and
                the only accepted `check_params` are `multi_output` and
                `y_numeric`.
      :type X: {array-like, sparse matrix, dataframe} of shape                 (n_samples, n_features), default='no validation'
      :param y: The targets.

                - If `None`, `check_array` is called on `X`. If the estimator's
                  requires_y tag is True, then an error will be raised.
                - If `'no_validation'`, `check_array` is called on `X` and the
                  estimator's requires_y tag is ignored. This is a default
                  placeholder and is never meant to be explicitly set. In that case
                  `X` must be passed.
                - Otherwise, only `y` with `_check_y` or both `X` and `y` are
                  checked with either `check_array` or `check_X_y` depending on
                  `validate_separately`.
      :type y: array-like of shape (n_samples,), default='no_validation'
      :param reset: Whether to reset the `n_features_in_` attribute.
                    If False, the input will be checked for consistency with data
                    provided when reset was last True.
                    .. note::
                       It is recommended to call reset=True in `fit` and in the first
                       call to `partial_fit`. All other methods that validate `X`
                       should set `reset=False`.
      :type reset: bool, default=True
      :param validate_separately: Only used if y is not None.
                                  If False, call validate_X_y(). Else, it must be a tuple of kwargs
                                  to be used for calling check_array() on X and y respectively.

                                  `estimator=self` is automatically added to these dicts to generate
                                  more informative error message in case of invalid input data.
      :type validate_separately: False or tuple of dicts, default=False
      :param cast_to_ndarray: Cast `X` and `y` to ndarray with checks in `check_params`. If
                              `False`, `X` and `y` are unchanged and only `feature_names_in_` and
                              `n_features_in_` are checked.
      :type cast_to_ndarray: bool, default=True
      :param \*\*check_params: Parameters passed to :func:`sklearn.utils.check_array` or
                               :func:`sklearn.utils.check_X_y`. Ignored if validate_separately
                               is not False.

                               `estimator=self` is automatically added to these params to generate
                               more informative error message in case of invalid input data.
      :type \*\*check_params: kwargs

      :returns: **out** -- The validated input. A tuple is returned if both `X` and `y` are
                validated.
      :rtype: {ndarray, sparse matrix} or tuple of these


   .. py:method:: _validate_timestamp_format(x: pandas.DataFrame, timestamp_format: str = '%Y-%m-%d %H:%M:%S')



.. py:class:: Timestamp


   .. py:method:: execution_time(case, ix_list, **kwargs)
      :classmethod:


   .. py:method:: accumulated_time(case, ix_list, **kwargs)
      :classmethod:


   .. py:method:: remaining_time(case, ix_list, **kwargs)
      :classmethod:


   .. py:method:: within_day(X, **kwargs)
      :classmethod:



