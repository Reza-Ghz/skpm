:py:mod:`skpm.event_feature_extraction.meta`
============================================

.. py:module:: skpm.event_feature_extraction.meta


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   skpm.event_feature_extraction.meta.DigraphFeaturesExtractor
   skpm.event_feature_extraction.meta._DigraphFeatures




.. py:class:: DigraphFeaturesExtractor


   Bases: :py:obj:`sklearn.base.TransformerMixin`, :py:obj:`sklearn.base.BaseEstimator`

   Mixin class for all transformers in scikit-learn.

   If :term:`get_feature_names_out` is defined, then :class:`BaseEstimator` will
   automatically wrap `transform` and `fit_transform` to follow the `set_output`
   API. See the :ref:`developer_api_set_output` for details.

   :class:`OneToOneFeatureMixin` and
   :class:`ClassNamePrefixFeaturesOutMixin` are helpful mixins for
   defining :term:`get_feature_names_out`.

   .. py:method:: fit(X, y=None)


   .. py:method:: transform(X, y=None)



.. py:class:: _DigraphFeatures


   .. py:method:: _frequency_matrix(traces: list, set_of_states: set) -> tuple[numpy.ndarray, dict, dict]
      :classmethod:

      Returns a transition frequency matrix.

      This function takes a list of traces, where each trace
      is an ordered sequence of states, and computes a transition
      frequency matrix.

      States can be any hashable object, but they must be comparable.
      For instance, a state can be a string, an integer, or a tuple.

      :param traces: A list of traces, where each trace is a list of states.
      :type traces: list of list of states
      :param set_of_states: A set of all possible states.
      :type set_of_states: set of states

      :returns: * **freq_matrix** (*numpy.ndarray*) -- A transition frequency matrix.
                * **stoi** (*dict*) -- A dictionary mapping states to indices.
                * **itos** (*dict*) -- A dictionary mapping indices to states.

      .. rubric:: Examples

      >>> traces = [[1, 2, 3], [1, 2, 3, 4]]
      >>> set_of_states = {1, 2, 3, 4}
      >>> frequency_matrix(traces, set_of_states)
      (array([[0, 2, 0, 0],
              [0, 0, 2, 0],
              [0, 0, 0, 1],
              [0, 0, 0, 0]]),
      {1: 0, 2: 1, 3: 2, 4: 3},
      {0: 1, 1: 2, 2: 3, 3: 4})

      >>> traces = [["a", "b", "c"], ["a", "b", "c", "d"]]
      >>> set_of_states = {"a", "b", "c", "d"}
      >>> frequency_matrix(traces, set_of_states)
      (array([[0, 0, 2, 0],
              [2, 0, 0, 0],
              [0, 0, 0, 1],
              [0, 0, 0, 0]]),
      {'b': 0, 'a': 1, 'c': 2, 'd': 3},
      {0: 'b', 1: 'a', 2: 'c', 3: 'd'})

      >>> traces = [[("a", "b"), ("b", "c")], [("a", "b"), ("b", "c"), ("c", "d")]]
      >>> set_of_states = {("a", "b"), ("b", "c"), ("c", "d")}
      >>> frequency_matrix(traces, set_of_states)
      (array([[0, 0, 0],
              [1, 0, 0],
              [0, 2, 0]]),
      {('c', 'd'): 0, ('b', 'c'): 1, ('a', 'b'): 2},
      {0: ('c', 'd'), 1: ('b', 'c'), 2: ('a', 'b')})


   .. py:method:: node_degree(frequency_matrix: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]
      :classmethod:

      Returns the in-degree and out-degree of each node.

      :param frequency_matrix: A graph as a transition frequency matrix.
      :type frequency_matrix: numpy.ndarray

      :returns: * **in_degree** (*numpy.ndarray*) -- An array with the in-degree of each node.
                * **out_degree** (*numpy.ndarray*) -- An array with the out-degree of each node.


   .. py:method:: density(graph)
      :classmethod:

      Returns the density of a graph.

      :param graph: A graph as a transition frequency matrix.
      :type graph: numpy.ndarray

      :returns: **density** -- The density of the graph.
      :rtype: float


   .. py:method:: nodes_in_cycles(frequency_matrix, max_cycle_length)
      :classmethod:

      Returns a list of whether each node is in a cycle.

      Notice: this function actually returns self-loops, not cycles.
      By definition, a cycle is a path that starts and ends at the same node
      and visits each node at most once. A self-loop is an edge that connects
      a node to itself. A self-loop is a cycle of length 1.


      :param frequency_matrix: A graph as a transition frequency matrix.
      :type frequency_matrix: numpy.ndarray
      :param max_cycle_length: The maximum length of a cycle to be counted.
      :type max_cycle_length: int

      :returns: **in_cycle** -- A list of whether each node is in a cycle.
      :rtype: list of bool



