:py:mod:`skpm.utils.graph`
==========================

.. py:module:: skpm.utils.graph


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   skpm.utils.graph.frequency_matrix
   skpm.utils.graph.node_degree



.. py:function:: frequency_matrix(traces: list, set_of_states: set) -> tuple[numpy.ndarray, dict, dict]

   Returns a transition frequency matrix.

   This function takes a list of traces, where each trace
   is an ordered sequence of states, and computes a transition
   frequency matrix.

   States can be any hashable object, but they must be comparable.
   For instance, a state can be a string, an integer, or a tuple.

   :param traces: A list of traces, where each trace is a list of states.
   :type traces: list of list of states
   :param set_of_states: A set of all possible states.
   :type set_of_states: set of states

   :returns: * **freq_matrix** (*numpy.ndarray*) -- A transition frequency matrix.
             * **stoi** (*dict*) -- A dictionary mapping states to indices.
             * **itos** (*dict*) -- A dictionary mapping indices to states.

   .. rubric:: Examples

   >>> traces = [[1, 2, 3], [1, 2, 3, 4]]
   >>> set_of_states = {1, 2, 3, 4}
   >>> frequency_matrix(traces, set_of_states)
   (array([[0, 2, 0, 0],
           [0, 0, 2, 0],
           [0, 0, 0, 1],
           [0, 0, 0, 0]]),
    {1: 0, 2: 1, 3: 2, 4: 3},
    {0: 1, 1: 2, 2: 3, 3: 4})

   >>> traces = [["a", "b", "c"], ["a", "b", "c", "d"]]
   >>> set_of_states = {"a", "b", "c", "d"}
   >>> frequency_matrix(traces, set_of_states)
   (array([[0, 0, 2, 0],
           [2, 0, 0, 0],
           [0, 0, 0, 1],
           [0, 0, 0, 0]]),
    {'b': 0, 'a': 1, 'c': 2, 'd': 3},
    {0: 'b', 1: 'a', 2: 'c', 3: 'd'})

   >>> traces = [[("a", "b"), ("b", "c")], [("a", "b"), ("b", "c"), ("c", "d")]]
   >>> set_of_states = {("a", "b"), ("b", "c"), ("c", "d")}
   >>> frequency_matrix(traces, set_of_states)
   (array([[0, 0, 0],
           [1, 0, 0],
           [0, 2, 0]]),
    {('c', 'd'): 0, ('b', 'c'): 1, ('a', 'b'): 2},
    {0: ('c', 'd'), 1: ('b', 'c'), 2: ('a', 'b')})


.. py:function:: node_degree(frequency_matrix: numpy.ndarray) -> tuple[numpy.ndarray, numpy.ndarray]

   Returns the in-degree and out-degree of each node.

   :param frequency_matrix: A graph as a transition frequency matrix.
   :type frequency_matrix: numpy.ndarray

   :returns: * **in_degree** (*numpy.ndarray*) -- An array with the in-degree of each node.
             * **out_degree** (*numpy.ndarray*) -- An array with the out-degree of each node.


